--log means log base 2
-- in little endian 12345678 will be stored as 78563412 not as 87654321 
-- x = 1234 converts 1234 in binary then stores it while x = 0x1234 stores it directly
-- we can use char* to an integer address and thus access each byte of integer element

******* unset right most set bit
n = n & (n-1)

******* 2's complement
-x = 2's complement of x = 1's complement of x + 1
so 2's complement is just negative of that number

******* get rughtmost bit
 n&-n  and its position is given by log( n&-n )

******* get n bits at position p from x
set1 = ( x >> p ) & ((1U << n)-1 )

******* avoid doing loop over set bits 
as it takes lot of time. eg: for calculating parity rather than looping like
while( n!= 0 ){ //loops until rightmost bit times
 (n >> 1) & 1
}

use

while( n!= 0 ){ //loops untill number of set bits time
	parity = !parity;
	n = n & (n-1);
}

******* use increment/decrement operators, 

******* finding next power of 2
n--
n = n | n >> 1
n = n | n >> 2
n = n | n >> 4
n = n | n >> 8
n = n | n >> 16
return n + 1

******* position of set bit in p is given by: log(n)

******* check if n is power of 2
n is power of 2 if n & (n-1) == 0 but it won't work for n = 0
so use n & !( n&(n-1) ) instead

******* check if a number is multiple of 3
count all set bits at odd positions CSO
count all set bits at even positions CSE
if CSO - CSE is multiple of 2 then number is also multiple of 3

because in base 10 or decimal numbers if sum of odd digits - sum of even digits is mulple of 11 then number is multiple of 11. similarly in base 2.

***** multiply by p
say p is 7; now break 7 into 8 - 1; 7n = 8n - n; and use shift operators like
n << 3 - n

***** when using 
if( x&(x-1) == 0 ) printf("power of 2");
else printf("not power of 2")

it doesn't works; to work properly use bracket around x&(x-1)
if( (x&(x-1)) == 0 )
because precedence of == is more than & so (x-1) == 0 is ecaluated first giving 0 which is then & with x giving 0 and executing else part.

***** for efficient lookup table
for large number of elements in array if we need to count no of set bits. for each number use pointer to char and lookup from table can give us efficient result. lookup table follows a pattern which can be generated by using following macros:

/* GROUP_A - When combined with META_LOOK_UP
   generates count for 4x4 elements */
 
#define GROUP_A(x) x, x + 1, x + 1, x + 2
 
/* GROUP_B - When combined with META_LOOK_UP
   generates count for 4x4x4 elements */
 
#define GROUP_B(x) GROUP_A(x), GROUP_A(x+1), GROUP_A(x+1), GROUP_A(x+2)
 
/* GROUP_C - When combined with META_LOOK_UP
   generates count for 4x4x4x4 elements */
 
#define GROUP_C(x) GROUP_B(x), GROUP_B(x+1), GROUP_B(x+1), GROUP_B(x+2)
 
/* Provide appropriate letter to generate the table */
 
#define META_LOOK_UP(PARAMETER) \
   GROUP_##PARAMETER(0),  \
   GROUP_##PARAMETER(1),  \
   GROUP_##PARAMETER(1),  \
   GROUP_##PARAMETER(2)   \

********** 
to change arr of two elements with 0,1 only changing it to 0,0 without any operations:

arr[ arr[1] ] = arr[ arr[0] ];

or

arr[0] = arr[ arr[0] ] // make 0 at arr[0]
arr[1] = arr[0]

********** finding smallest of three numbers without if-else

while( x & y & z ){
	x--; y--; z--; cnt++;        
}
return cnt;

or

min( x, y ){

	return y + ( (x-y) & ((x-y) >> 31);

}

( (x-y) & ((x-y) >> 31); is 0 when x > y
and produces result when x < y

********** adding two numbers without +
add( x, y )
	while( y != 0 ){
		carry = x & y;
		x = x ^ y;
		y = carry << 1;
	}
	return x;

********** swapping n bits at given two positions and return result
use xor algo for swapping: (( a xor b ) xor a )gives b

so get set bits
set1 = ( x >> p1 ) & ((1U << n)-1 )
set2 = ( x >> p2 ) & ((1U << n)-1 )

xor = set1 ^ set2
xor = (xor << p1) | (xor << p2)
x = x ^ xor

*****given two numbers get max of them wiyhouy cond operayors

10 - 6 = 4
10 - rightmostbit * 4

now if 10 > 4 rightmost bit is zero return 10
ekse return 6

Let c = a - b. Let k = the most significant bit of c. Return a - k * c.

 int
 getMax(int a, int b) {
 int c = a - b;
 int k = (c >> 31) & 0x1;
 int max = a - k * c;
 return max;
 }

***** bits from tc *****
consider bits as set so following ops are possible:
Set union : A | B
Set intersection : A & B
Set subtraction : A & ~B // it is very good op; it removes elements from A which are common in B; its not effected if some extra elements are present in B
Set negation : ALL_BITS ^ A
Set bit : A |= 1 << bit
Clear bit : A &= ~(1 << bit)
Test bit : (A & 1 << bit) != 0

lowest set bit's value = x & ~(x-1) but for finding index we need to loop through bits.

When executing shift instructions for a << b, the x86 architecture uses only the bottom 5 bits of b (6 for 64-bit integers). This means that shifting left (or right) by 32 does nothing, rather than clearing all the bits.

The & and | operators have lower precedence than comparison operators. That means that x & 3 == 1 is interpreted as x & (3 == 1).

If you want to write completely portable C/C++ code, be sure to use unsigned types, particularly if you plan to use the top-most bit. C99 says that shift operations on negative values are undefined.













